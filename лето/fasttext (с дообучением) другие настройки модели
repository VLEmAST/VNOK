import sys
import mmap
import pickle
import string
import fasttext
import numpy as np
import pandas as pd
import orjson
import pymorphy3
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from functools import lru_cache
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QLineEdit, QPushButton,
    QVBoxLayout, QHBoxLayout, QFileDialog, QComboBox, QTextEdit,
    QMessageBox, QProgressBar, QGroupBox
)
from PyQt6.QtGui import QFont, QTextCursor
from PyQt6.QtCore import QObject, pyqtSignal, QThread, Qt, QTimer
from sklearn.metrics.pairwise import cosine_similarity

try:
    from docx import Document
except ImportError:
    Document = None

# Инициализация анализатора с кэшированием
morph = pymorphy3.MorphAnalyzer()

class CompareWorker(QObject):
    progress = pyqtSignal(int)
    results_ready = pyqtSignal(list)
    finished = pyqtSignal()

    def __init__(self, threat_data, vulnerability_data, reference_text, model, stop_words, morph):
        super().__init__()
        self.threat_data = threat_data
        self.vulnerability_data = vulnerability_data
        self.reference_text = reference_text
        self.model = model
        self.stop_words = stop_words
        self.morph = morph
        self.should_stop = False
        self.punctuation_translator = str.maketrans("", "", string.punctuation)
        self._morph_cache = {}

    @lru_cache(maxsize=10000)
    def _lemmatize_word(self, word):
        return self.morph.parse(word)[0].normal_form

    def preprocess_text(self, text):
        if not isinstance(text, str):
            return ""
            
        text = text.translate(self.punctuation_translator).lower()
        words = text.split()
        lemmatized_words = [
            self._lemmatize_word(word)
            for word in words 
            if word and word not in self.stop_words
        ]
        return " ".join(lemmatized_words)

    def process(self):
        try:
            self.progress.emit(20)
            
            target_desc = self.preprocess_text(self.reference_text)
            target_vector = self.model.get_sentence_vector(target_desc).reshape(1, -1)
            
            self.progress.emit(30)

            threat_vectors = []
            for i, item in enumerate(self.threat_data):
                if self.should_stop:
                    break
                    
                if i % 10 == 0:
                    QApplication.processEvents()
                    
                text = self.preprocess_text(f"{item.get('Name', '')} {item.get('Description', '')}")
                vector = self.model.get_sentence_vector(text)
                threat_vectors.append((item, vector))

            if self.should_stop:
                return
                
            threat_matrix = np.array([v[1] for v in threat_vectors])
            similarities = cosine_similarity(target_vector, threat_matrix).flatten()
            top_threat_indices = np.argsort(similarities)[-5:][::-1]
            top_threats = [(threat_vectors[i][0], similarities[i]) for i in top_threat_indices]

            self.progress.emit(70)

            results = []
            for threat, similarity in top_threats:
                if self.should_stop:
                    break
                    
                QApplication.processEvents()
                
                results.append(
                    f"Угроза: {threat.get('Name', '')}\n"
                    f"Описание: {threat.get('Description', '')}\n"
                    f"Нарушение конфиденциальности: {threat.get('PrivacyViolation', '0')}\n"
                    f"Нарушение целостности: {threat.get('IntegrityViolation', '0')}\n"
                    f"Нарушение доступности: {threat.get('AccessibilityViolation', '0')}\n"
                    f"Сходство: {similarity:.4f}\n"
                )

                filtered_vulns = [
                    vuln for vuln in self.vulnerability_data
                    if self._check_criteria(threat, vuln)
                ]
                
                if filtered_vulns and not self.should_stop:
                    vuln_vectors = []
                    for vuln in filtered_vulns:
                        if self.should_stop:
                            break
                            
                        text = self.preprocess_text(f"{vuln.get('Name', '')} {vuln.get('Description', '')}")
                        vector = self.model.get_sentence_vector(text)
                        vuln_vectors.append((vuln, vector))

                    if not self.should_stop:
                        vuln_matrix = np.array([v[1] for v in vuln_vectors])
                        threat_text = self.preprocess_text(f"{threat.get('Name', '')} {threat.get('Description', '')}")
                        threat_vector = self.model.get_sentence_vector(threat_text).reshape(1, -1)
                        vuln_similarities = cosine_similarity(threat_vector, vuln_matrix).flatten()
                        top_vuln_indices = np.argsort(vuln_similarities)[-3:][::-1]

                        for i, idx in enumerate(top_vuln_indices, 1):
                            if self.should_stop:
                                break
                                
                            QApplication.processEvents()
                            
                            vuln = filtered_vulns[idx]
                            results.append(
                                f"  Уязвимость #{i}:\n"
                                f"    Название: {vuln.get('Name', '')}\n"
                                f"    Описание: {vuln.get('Description', '')}\n"
                                f"    CVSS2: {vuln.get('CVSS2', '')}\n"
                                f"    Сходство с угрозой: {vuln_similarities[idx]:.4f}\n"
                            )

            if not self.should_stop:
                self.progress.emit(100)
                self.results_ready.emit(results)

        except Exception as e:
            self.results_ready.emit([f"Ошибка: {str(e)}"])
        finally:
            self.finished.emit()

    def _check_criteria(self, threat, vuln):
        privacy = threat.get("PrivacyViolation", "0")
        integrity = threat.get("IntegrityViolation", "0")
        availability = threat.get("AccessibilityViolation", "0")
        vuln_cvss = vuln.get("CVSS2", "")
        
        privacy_match = (privacy == "1" and "C:C" in vuln_cvss) or (privacy == "0" and "C:C" not in vuln_cvss)
        integrity_match = (integrity == "1" and "I:C" in vuln_cvss) or (integrity == "0" and "I:C" not in vuln_cvss)
        availability_match = (availability == "1" and "A:C" in vuln_cvss) or (availability == "0" and "A:C" not in vuln_cvss)
        
        return privacy_match and integrity_match and availability_match

class Worker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(int)
    message = pyqtSignal(str)
    data_loaded = pyqtSignal(bool)
    model_trained = pyqtSignal(bool)
    results_ready = pyqtSignal(list)
    model_loaded = pyqtSignal(bool)
    stopwords_loaded = pyqtSignal(bool)

    def __init__(self):
        super().__init__()
        self.stop_words = set()
        self.all_descriptions = []
        self.all_names = []
        self.loaded_files = []
        self.model = None
        self.df = None
        self.punctuation_translator = str.maketrans("", "", string.punctuation)
        self.cache_dir = Path("cache")
        self.cache_dir.mkdir(exist_ok=True)
        self.is_working = False
        self.should_stop = False
        self._morph_cache = {}

    @lru_cache(maxsize=10000)
    def _lemmatize_word(self, word):
        return morph.parse(word)[0].normal_form

    def get_cache_key(self, filepath):
        path = Path(filepath)
        return f"{path.name}_{path.stat().st_size}"

    def load_from_cache(self, filepath):
        cache_file = self.cache_dir / f"{self.get_cache_key(filepath)}.pkl"
        if not cache_file.exists():
            return None

        try:
            with open(cache_file, "rb") as f:
                with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as mm:
                    return pickle.loads(mm.read())
        except:
            return None

    def save_to_cache(self, filepath, data):
        cache_file = self.cache_dir / f"{self.get_cache_key(filepath)}.pkl"
        with open(cache_file, "wb") as f:
            pickle.dump(data, f, protocol=5)

    def preprocess_text(self, text):
        if not isinstance(text, str):
            return ""
            
        text = text.translate(self.punctuation_translator).lower()
        words = text.split()
        lemmatized_words = [
            self._lemmatize_word(word)
            for word in words 
            if word and word not in self.stop_words
        ]
        return " ".join(lemmatized_words)

    def _process_file(self, filepath):
        if self.should_stop:
            return []

        cached_data = self.load_from_cache(filepath)
        if cached_data is not None:
            return cached_data

        try:
            with open(filepath, "rb") as f:
                data = orjson.loads(f.read())
        except Exception as e:
            self.message.emit(f"Ошибка чтения {filepath}: {str(e)}")
            return []

        if not isinstance(data, list):
            data = [data]

        processed_data = []
        for item in data:
            if self.should_stop:
                return []
                
            if not isinstance(item, dict):
                continue
                
            if "Techniques" in item and isinstance(item["Techniques"], list):
                processed_data.extend(
                    (tech["Name"], tech["Description"])
                    for tech in item["Techniques"]
                    if isinstance(tech, dict) and "Description" in tech and "Name" in tech
                )
            elif "Entities" in item and isinstance(item["Entities"], list):
                processed_data.extend(
                    (entity["Name"], entity["Description"])
                    for entity in item["Entities"]
                    if isinstance(entity, dict) and "Description" in entity and "Name" in entity
                )
            elif "Description" in item and "Name" in item:
                processed_data.append((item["Name"], item["Description"]))

        self.save_to_cache(filepath, processed_data)
        return processed_data

    def load_data_from_files(self, filepaths):
        if self.is_working:
            self.message.emit("Операция уже выполняется")
            return

        self.is_working = True
        self.should_stop = False
        try:
            QApplication.processEvents()
            
            self.all_descriptions = []
            self.all_names = []
            self.loaded_files = filepaths
            
            with ThreadPoolExecutor(max_workers=min(32, (os.cpu_count() or 1) * 4)) as executor:
                futures = {executor.submit(self._process_file, fp): fp for fp in filepaths}
                
                for i, future in enumerate(as_completed(futures)):
                    if self.should_stop:
                        break
                        
                    if i % 5 == 0:
                        QApplication.processEvents()
                    
                    filepath = futures[future]
                    try:
                        data = future.result()
                        names, descs = zip(*data) if data else ([], [])
                        self.all_names.extend(names)
                        self.all_descriptions.extend(descs)
                    except Exception as e:
                        self.message.emit(f"Ошибка в файле {filepath}: {str(e)}")
                    
                    self.progress.emit(int((i + 1) / len(filepaths) * 50))

            if not self.should_stop and self.all_names:
                preprocessed_names = []
                preprocessed_descriptions = []
                
                total = len(self.all_names)
                chunk_size = 1000
                
                for i in range(0, total, chunk_size):
                    if self.should_stop:
                        break
                        
                    chunk_names = self.all_names[i:i+chunk_size]
                    chunk_descs = self.all_descriptions[i:i+chunk_size]
                    
                    with ThreadPoolExecutor(max_workers=os.cpu_count() or 1) as executor:
                        name_futures = [executor.submit(self.preprocess_text, name) for name in chunk_names]
                        desc_futures = [executor.submit(self.preprocess_text, desc) for desc in chunk_descs]
                        
                        preprocessed_names.extend(f.result() for f in name_futures)
                        preprocessed_descriptions.extend(f.result() for f in desc_futures)
                    
                    self.progress.emit(50 + int((i / total) * 50))

                if not self.should_stop:
                    self.df = pd.DataFrame({
                        "name": pd.Series(preprocessed_names, dtype="string"),
                        "description": pd.Series(preprocessed_descriptions, dtype="string")
                    })
                    self.data_loaded.emit(True)
                else:
                    self.data_loaded.emit(False)
            else:
                self.message.emit("Ошибка: Нет данных для обработки" if not self.should_stop else "Операция прервана")
                self.data_loaded.emit(False)
                
        except Exception as e:
            self.message.emit(f"Критическая ошибка: {str(e)}")
            self.data_loaded.emit(False)
        finally:
            self.is_working = False
            self.finished.emit()

    def load_stopwords(self, filepath):
        if self.is_working:
            self.message.emit("Операция уже выполняется")
            return

        self.is_working = True
        self.should_stop = False
        try:
            QApplication.processEvents()
            
            with open(filepath, "rb") as f:
                loaded_stopwords = orjson.loads(f.read())
                
                if isinstance(loaded_stopwords, list):
                    self.stop_words = frozenset(loaded_stopwords)
                elif isinstance(loaded_stopwords, dict) and "stop_words" in loaded_stopwords:
                    self.stop_words = frozenset(loaded_stopwords["stop_words"])
                else:
                    raise ValueError("Неверный формат файла стоп-слов")
            
            self.message.emit(f"Загружено {len(self.stop_words)} стоп-слов")
            self.stopwords_loaded.emit(True)
        except Exception as e:
            self.message.emit(f"Ошибка при загрузке стоп-слов: {str(e)}")
            self.stopwords_loaded.emit(False)
        finally:
            self.is_working = False
            self.finished.emit()

    def load_model(self, filepath):
        if self.is_working:
            self.message.emit("Операция уже выполняется")
            return

        self.is_working = True
        self.should_stop = False
        try:
            QApplication.processEvents()
            
            self.model = fasttext.load_model(filepath)
            self.message.emit(f"Модель загружена из {os.path.basename(filepath)}")
            self.model_loaded.emit(True)
        except Exception as e:
            self.message.emit(f"Ошибка при загрузке модели: {str(e)}")
            self.model_loaded.emit(False)
        finally:
            self.is_working = False
            self.finished.emit()

    def train_model(self):
        if self.is_working:
            self.message.emit("Операция уже выполняется")
            return

        self.is_working = True
        self.should_stop = False
        try:
            QApplication.processEvents()
            
            if not hasattr(self, 'df') or self.df.empty:
                raise ValueError("Нет данных для обучения")
            
            # Сохраняем текущую модель во временный файл, если она существует
            old_model_path = None
            if self.model is not None:
                old_model_path = self.cache_dir / "temp_old_model.bin"
                self.model.save_model(str(old_model_path))
            
            # Создаем файл для обучения
            train_file = self.cache_dir / "train.txt"
            with open(train_file, "w", encoding="utf-8") as f:
                for i, (name, desc) in enumerate(zip(self.df["name"], self.df["description"])):
                    if self.should_stop:
                        break
                        
                    if i % 100 == 0:
                        QApplication.processEvents()
                        
                    f.write(f"{name}\n{desc}\n")

            if not self.should_stop:
                # Если есть старая модель, создаем новый файл обучения с объединенными данными
                if old_model_path and old_model_path.exists():
                    self.message.emit("Дообучение модели...")
                    
                    # Получаем слова из старой модели
                    old_words = set(self.model.get_words())
                    
                    # Создаем расширенный файл обучения
                    extended_train_file = self.cache_dir / "extended_train.txt"
                    with open(extended_train_file, "w", encoding="utf-8") as out_f:
                        # Добавляем слова из старой модели (имитируем предыдущие данные)
                        for word in old_words:
                            if word not in ['</s>', '<s>']:  # Исключаем служебные токены
                                out_f.write(f"{word}\n")
                        
                        # Добавляем новые данные
                        with open(train_file, "r", encoding="utf-8") as in_f:
                            out_f.write(in_f.read())
                    
                    # Обучаем новую модель на расширенных данных
                    self.model = fasttext.train_unsupervised(
                        str(extended_train_file),
                        model='skipgram',      # Лучше для семантических задач
                        dim=300,               # Увеличиваем размерность для сложных текстов
                        epoch=50,              # Больше эпох для лучшего обучения
                        lr=0.05,               # Скорость обучения
                        ws=5,                  # Размер окна контекста
                        minCount=3,            # Минимальная частота слова
                        minn=3,                # Минимальная длина n-gram
                        maxn=6,                # Максимальная длина n-gram  
                        neg=10,                # Количество negative samples
                        wordNgrams=2,          # Использовать биграммы
                        thread=os.cpu_count(), # Использовать все ядра
                        verbose=2
                    )
                    
                    # Удаляем временные файлы
                    if extended_train_file.exists():
                        extended_train_file.unlink()
                        
                else:
                    # Создаем новую модель
                    self.message.emit("Создание новой модели...")
                    self.model = fasttext.train_unsupervised(
                        str(train_file),
                        model="skipgram",
                        dim=200,
                        epoch=20,
                        ws=5,
                        minCount=5,
                        thread=os.cpu_count()
                    )

            # Очистка временных файлов
            if train_file.exists():
                train_file.unlink()
            if old_model_path and old_model_path.exists():
                old_model_path.unlink()
                
            if not self.should_stop:
                self.message.emit("Модель успешно обучена!")
                self.model_trained.emit(True)
            else:
                self.model_trained.emit(False)
        except Exception as e:
            self.message.emit(f"Ошибка при обучении модели: {str(e)}")
            self.model_trained.emit(False)
        finally:
            self.is_working = False
            self.finished.emit()

    def save_model_to_file(self, filepath):
        if self.is_working:
            self.message.emit("Операция уже выполняется")
            return False

        self.is_working = True
        try:
            QApplication.processEvents()
            
            if not self.model:
                self.message.emit("Нет модели для сохранения")
                return False
            
            self.model.save_model(filepath)
            self.message.emit(f"Модель сохранена в {filepath}")
            return True
        except Exception as e:
            self.message.emit(f"Ошибка при сохранении модели: {str(e)}")
            return False
        finally:
            self.is_working = False

    def find_most_similar(self, reference_text, file_index, top_n=3):
        if self.is_working:
            self.message.emit("Операция уже выполняется")
            return

        self.is_working = True
        self.should_stop = False
        try:
            QApplication.processEvents()
            self.message.emit("Анализ текста...")
            self.progress.emit(10)
            
            filename = os.path.basename(self.loaded_files[file_index])
            
            with open(self.loaded_files[file_index], "rb") as f:
                analysis_data = orjson.loads(f.read())
                if not isinstance(analysis_data, list):
                    analysis_data = [analysis_data]

            self.progress.emit(30)
            
            if self.should_stop:
                return
                
            target_desc = self.preprocess_text(reference_text)
            target_vector = self.model.get_sentence_vector(target_desc).reshape(1, -1)

            has_techniques = any(
                "Techniques" in item and isinstance(item["Techniques"], list)
                for item in analysis_data
                if isinstance(item, dict)
            )

            if has_techniques:
                tactics_techniques = []
                tactics_info = {}
                
                for item in analysis_data:
                    if self.should_stop:
                        break
                        
                    if isinstance(item, dict) and "Techniques" in item and isinstance(item["Techniques"], list):
                        tactic_name = item.get("Name", "Без названия")
                        tactic_desc = item.get("Description", "")
                        tactics_info[tactic_name] = tactic_desc
                        
                        for tech in item["Techniques"]:
                            if isinstance(tech, dict) and "Description" in tech and "Name" in tech:
                                tactics_techniques.append({
                                    "tactic": tactic_name,
                                    "tech_name": tech["Name"],
                                    "tech_desc": tech["Description"]
                                })

                if self.should_stop:
                    return
                    
                similarities = []
                total_items = len(tactics_techniques)
                batch_size = max(1, total_items // 20)
                
                for i, item in enumerate(tactics_techniques):
                    if self.should_stop:
                        break
                        
                    if i % 5 == 0:
                        QApplication.processEvents()
                        
                    processed_desc = self.preprocess_text(f"{item['tech_name']} {item['tech_desc']}")
                    vector = self.model.get_sentence_vector(processed_desc).reshape(1, -1)
                    similarity = cosine_similarity(target_vector, vector)[0][0]
                    similarities.append((item, similarity))
                    
                    if i % batch_size == 0:
                        self.progress.emit(30 + int((i / total_items) * 60))

                if not self.should_stop:
                    similarities.sort(key=lambda x: x[1], reverse=True)
                    top_results = similarities[:top_n]

                    results = [f"Анализ выполнен для файла: {filename}\n\n"]
                    results.append(f"Опорное описание: '{reference_text}'\n\n")
                    
                    for i, (item, sim) in enumerate(top_results, 1):
                        results.append(
                            f"Результат #{i} (сходство: {sim:.4f}):\n"
                            f"Тактика: {item['tactic']}\n"
                            f"Описание тактики: {tactics_info.get(item['tactic'], 'Нет описания')}\n"
                            f"Техника: {item['tech_name']}\n"
                            f"Описание техники: {item['tech_desc']}\n"
                        )
            else:
                items = []
                for item in analysis_data:
                    if self.should_stop:
                        break
                        
                    if isinstance(item, dict):
                        item_name = item.get("Name", "")
                        item_desc = item.get("Description", "")
                        if item_name and item_desc:
                            items.append({
                                "name": item_name,
                                "description": item_desc
                            })

                if self.should_stop:
                    return
                    
                similarities = []
                total_items = len(items)
                batch_size = max(1, total_items // 20)
                
                for i, item in enumerate(items):
                    if self.should_stop:
                        break
                        
                    if i % 5 == 0:
                        QApplication.processEvents()
                        
                    processed_desc = self.preprocess_text(f"{item['name']} {item['description']}")
                    vector = self.model.get_sentence_vector(processed_desc).reshape(1, -1)
                    similarity = cosine_similarity(target_vector, vector)[0][0]
                    similarities.append((item, similarity))
                    
                    if i % batch_size == 0:
                        self.progress.emit(30 + int((i / total_items) * 60))

                if not self.should_stop:
                    similarities.sort(key=lambda x: x[1], reverse=True)
                    top_results = similarities[:top_n]

                    results = [f"Анализ выполнен для файла: {filename}\n\n"]
                    results.append(f"Опорное описание: '{reference_text}'\n\n")
                    
                    for i, (item, sim) in enumerate(top_results, 1):
                        results.append(
                            f"Результат #{i} (сходство: {sim:.4f}):\n"
                            f"Название: {item['name']}\n"
                            f"Описание: {item['description']}\n"
                        )
            
            self.progress.emit(100)
            self.results_ready.emit(results)
        
        except Exception as e:
            self.message.emit(f"Ошибка при анализе: {str(e)}")
            self.results_ready.emit([f"Произошла ошибка: {str(e)}"])
        finally:
            self.is_working = False
            self.finished.emit()

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Анализ текстовых описаний")
        self.setGeometry(100, 100, 1000, 800)
        
        self.worker = Worker()
        self.worker_thread = QThread()
        self.worker.moveToThread(self.worker_thread)
        
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.message.connect(self.update_status)
        self.worker.progress.connect(self.update_progress)
        self.worker.data_loaded.connect(self.handle_data_loaded)
        self.worker.model_trained.connect(self.handle_model_trained)
        self.worker.results_ready.connect(self.show_results)
        self.worker.model_loaded.connect(self.handle_model_loaded)
        self.worker.stopwords_loaded.connect(self.handle_stopwords_loaded)
        
        self.worker_thread.start()
        
        self.responsiveness_timer = QTimer()
        self.responsiveness_timer.timeout.connect(lambda: QApplication.processEvents())
        self.responsiveness_timer.start(100)
        
        self.init_ui()
        
    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout()
        central_widget.setLayout(main_layout)
        
        # 1. Группа загрузки данных
        load_group = QGroupBox("Загрузка данных")
        load_layout = QVBoxLayout()
        load_group.setLayout(load_layout)
        
        button_layout = QHBoxLayout()
        
        self.load_data_btn = QPushButton("Загрузить данные (JSON)")
        self.load_data_btn.clicked.connect(self.load_data_files)
        
        self.load_stopwords_btn = QPushButton("Загрузить стоп-слова")
        self.load_stopwords_btn.clicked.connect(self.load_stopwords)
        
        self.load_model_btn = QPushButton("Загрузить модель")
        self.load_model_btn.clicked.connect(self.load_model_file)
        
        self.cancel_btn = QPushButton("Отмена")
        self.cancel_btn.clicked.connect(self.cancel_operation)
        self.cancel_btn.setEnabled(False)
        
        button_layout.addWidget(self.load_data_btn)
        button_layout.addWidget(self.load_stopwords_btn)
        button_layout.addWidget(self.load_model_btn)
        button_layout.addWidget(self.cancel_btn)
        load_layout.addLayout(button_layout)
        
        self.data_progress = QProgressBar()
        self.data_progress.setRange(0, 100)
        self.data_progress.setVisible(False)
        load_layout.addWidget(self.data_progress)
        
        self.stopwords_progress = QProgressBar()
        self.stopwords_progress.setRange(0, 100)
        self.stopwords_progress.setVisible(False)
        load_layout.addWidget(self.stopwords_progress)
        
        self.model_progress = QProgressBar()
        self.model_progress.setRange(0, 100)
        self.model_progress.setVisible(False)
        load_layout.addWidget(self.model_progress)
        
        main_layout.addWidget(load_group)
        
        # 2. Группа обучения модели
        train_group = QGroupBox("Обучение модели")
        train_layout = QVBoxLayout()
        train_group.setLayout(train_layout)
        
        self.train_btn = QPushButton("Обучить модель FastText")
        self.train_btn.clicked.connect(self.train_model)
        train_layout.addWidget(self.train_btn)
        
        self.save_model_btn = QPushButton("Сохранить модель")
        self.save_model_btn.clicked.connect(self.save_model)
        self.save_model_btn.setEnabled(False)
        train_layout.addWidget(self.save_model_btn)
        
        self.train_progress = QProgressBar()
        self.train_progress.setRange(0, 100)
        self.train_progress.setVisible(False)
        train_layout.addWidget(self.train_progress)
        
        main_layout.addWidget(train_group)
        
        # 3. Группа анализа текста
        analysis_group = QGroupBox("Анализ текста")
        analysis_layout = QVBoxLayout()
        analysis_group.setLayout(analysis_layout)
        
        file_layout = QHBoxLayout()
        file_layout.addWidget(QLabel("Файл для анализа:"))
        
        self.file_combo = QComboBox()
        file_layout.addWidget(self.file_combo)
        analysis_layout.addLayout(file_layout)
        
        analysis_layout.addWidget(QLabel("Опорное описание:"))
        self.reference_input = QTextEdit()
        self.reference_input.setPlaceholderText("Введите текст для анализа...")
        analysis_layout.addWidget(self.reference_input)
        
        format_layout = QHBoxLayout()
        format_layout.addWidget(QLabel("Формат сохранения:"))
        
        self.format_combo = QComboBox()
        self.format_combo.addItems(["Текстовый файл", "Документ Word"])
        format_layout.addWidget(self.format_combo)
        analysis_layout.addLayout(format_layout)
        
        button_layout = QHBoxLayout()
        self.analyze_btn = QPushButton("Анализировать")
        self.analyze_btn.clicked.connect(self.analyze_text)
        
        self.save_btn = QPushButton("Сохранить результаты")
        self.save_btn.clicked.connect(self.save_results)
        self.save_btn.setEnabled(False)
        
        button_layout.addWidget(self.analyze_btn)
        button_layout.addWidget(self.save_btn)
        analysis_layout.addLayout(button_layout)
        
        self.analysis_progress = QProgressBar()
        self.analysis_progress.setRange(0, 100)
        self.analysis_progress.setVisible(False)
        analysis_layout.addWidget(self.analysis_progress)
        
        main_layout.addWidget(analysis_group)
        
        # 4. Группа сравнения угроз и уязвимостей
        compare_group = QGroupBox("Сравнение угроз и уязвимостей")
        compare_layout = QVBoxLayout()
        compare_group.setLayout(compare_layout)
        
        threat_layout = QHBoxLayout()
        threat_layout.addWidget(QLabel("Файл угроз:"))
        
        self.threat_combo = QComboBox()
        threat_layout.addWidget(self.threat_combo)
        compare_layout.addLayout(threat_layout)
        
        vuln_layout = QHBoxLayout()
        vuln_layout.addWidget(QLabel("Файл уязвимостей:"))
        
        self.vuln_combo = QComboBox()
        vuln_layout.addWidget(self.vuln_combo)
        compare_layout.addLayout(vuln_layout)
        
        compare_layout.addWidget(QLabel("Опорное описание:"))
        self.compare_reference_input = QTextEdit()
        self.compare_reference_input.setPlaceholderText("Введите текст для сравнения...")
        compare_layout.addWidget(self.compare_reference_input)
        
        self.compare_btn = QPushButton("Сравнить угрозы и уязвимости")
        self.compare_btn.clicked.connect(self.compare_threats_vulnerabilities)
        compare_layout.addWidget(self.compare_btn)
        
        self.compare_progress = QProgressBar()
        self.compare_progress.setRange(0, 100)
        self.compare_progress.setVisible(False)
        compare_layout.addWidget(self.compare_progress)
        
        main_layout.addWidget(compare_group)
        
        # 5. Результаты
        results_group = QGroupBox("Результаты")
        results_layout = QVBoxLayout()
        results_group.setLayout(results_layout)
        
        self.results_output = QTextEdit()
        self.results_output.setReadOnly(True)
        results_layout.addWidget(self.results_output)
        
        main_layout.addWidget(results_group)
        
        self.status_bar = QLabel("Готов к работе")
        main_layout.addWidget(self.status_bar)
        
        self.current_results = []
        
    def set_buttons_enabled(self, enabled):
        """Блокировка/разблокировка всех кнопок"""
        self.load_data_btn.setEnabled(enabled)
        self.load_stopwords_btn.setEnabled(enabled)
        self.load_model_btn.setEnabled(enabled)
        self.train_btn.setEnabled(enabled)
        self.save_model_btn.setEnabled(enabled)
        self.analyze_btn.setEnabled(enabled)
        self.save_btn.setEnabled(enabled)
        self.compare_btn.setEnabled(enabled)
        self.cancel_btn.setEnabled(not enabled)
        
    def start_operation(self):
        """Подготовка к выполнению длительной операции"""
        self.set_buttons_enabled(False)
        self.responsiveness_timer.start(100)
        
    def end_operation(self):
        """Завершение длительной операции"""
        self.set_buttons_enabled(True)
        self.responsiveness_timer.stop()
        
    def cancel_operation(self):
        """Отмена текущей операции"""
        self.worker.should_stop = True
        if hasattr(self, 'compare_worker'):
            self.compare_worker.should_stop = True
        self.update_status("Операция прерывается...")
        self.cancel_btn.setEnabled(False)
        
    def load_data_files(self):
        filepaths, _ = QFileDialog.getOpenFileNames(
            self, "Выберите файлы данных", "", "JSON Files (*.json)"
        )
        
        if filepaths:
            self.data_progress.setVisible(True)
            self.start_operation()
            self.worker.load_data_from_files(filepaths)

    def load_stopwords(self):
        filepath, _ = QFileDialog.getOpenFileName(
            self, "Выберите файл стоп-слов", "", "JSON Files (*.json)"
        )
        
        if filepath:
            self.stopwords_progress.setVisible(True)
            self.start_operation()
            self.worker.load_stopwords(filepath)

    def load_model_file(self):
        filepath, _ = QFileDialog.getOpenFileName(
            self, "Выберите файл модели", "", "FastText Model (*.bin)"
        )
        
        if filepath:
            self.model_progress.setVisible(True)
            self.start_operation()
            self.worker.load_model(filepath)

    def train_model(self):
        if not hasattr(self.worker, 'all_descriptions') or not self.worker.all_descriptions:
            QMessageBox.warning(self, "Предупреждение", "Сначала загрузите данные для обучения")
            return
        
        # Если модель уже загружена, запросим подтверждение на дообучение
        if hasattr(self.worker, 'model') and self.worker.model is not None:
            reply = QMessageBox.question(
                self, 
                "Подтверждение дообучения",
                "Модель уже загружена. Хотите дообучить ее на новых данных?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.No:
                return
        
        self.train_progress.setVisible(True)
        self.start_operation()
        self.worker.train_model()

    def save_model(self):
        if not hasattr(self.worker, 'model') or not self.worker.model:
            QMessageBox.warning(self, "Предупреждение", "Нет модели для сохранения")
            return
            
        filepath, _ = QFileDialog.getSaveFileName(
            self, "Сохранить модель", "", "FastText Model (*.bin)"
        )
        
        if filepath:
            if not filepath.endswith('.bin'):
                filepath += '.bin'
            
            self.model_progress.setVisible(True)
            self.start_operation()
            
            success = self.worker.save_model_to_file(filepath)
            self.model_progress.setVisible(False)
            self.end_operation()
            
            if success:
                QMessageBox.information(self, "Успех", "Модель успешно сохранена!")
            else:
                QMessageBox.warning(self, "Ошибка", "Не удалось сохранить модель")

    def analyze_text(self):
        reference_text = self.reference_input.toPlainText()
        if not reference_text:
            QMessageBox.warning(self, "Предупреждение", "Введите опорное описание")
            return
            
        if not hasattr(self.worker, 'model') or not self.worker.model:
            QMessageBox.warning(self, "Предупреждение", "Сначала загрузите или обучите модель")
            return
            
        if not hasattr(self.worker, 'loaded_files') or not self.worker.loaded_files:
            QMessageBox.warning(self, "Предупреждение", "Сначала загрузите файлы данных")
            return
            
        selected_index = self.file_combo.currentIndex()
        if selected_index < 0 or selected_index >= len(self.worker.loaded_files):
            QMessageBox.warning(self, "Предупреждение", "Выберите файл для анализа")
            return
            
        self.analysis_progress.setVisible(True)
        self.start_operation()
        self.worker.find_most_similar(reference_text, selected_index)

    def compare_threats_vulnerabilities(self):
        reference_text = self.compare_reference_input.toPlainText()
        if not reference_text:
            QMessageBox.warning(self, "Предупреждение", "Введите опорное описание")
            return
            
        if not hasattr(self.worker, 'model') or not self.worker.model:
            QMessageBox.warning(self, "Предупреждение", "Сначала загрузите или обучите модель")
            return
            
        threat_index = self.threat_combo.currentIndex()
        vuln_index = self.vuln_combo.currentIndex()
        
        if threat_index < 0 or threat_index >= len(self.worker.loaded_files):
            QMessageBox.warning(self, "Предупреждение", "Выберите файл угроз")
            return
            
        if vuln_index < 0 or vuln_index >= len(self.worker.loaded_files):
            QMessageBox.warning(self, "Предупреждение", "Выберите файл уязвимостей")
            return
            
        try:
            self.compare_progress.setVisible(True)
            self.start_operation()
            
            with open(self.worker.loaded_files[threat_index], "rb") as f:
                threat_data = orjson.loads(f.read())
                if not isinstance(threat_data, list):
                    threat_data = [threat_data]

            with open(self.worker.loaded_files[vuln_index], "rb") as f:
                vulnerability_data = orjson.loads(f.read())
                if not isinstance(vulnerability_data, list):
                    vulnerability_data = [vulnerability_data]

            self.compare_thread = QThread()
            self.compare_worker = CompareWorker(
                threat_data,
                vulnerability_data,
                reference_text,
                self.worker.model,
                self.worker.stop_words,
                morph
            )
            self.compare_worker.moveToThread(self.compare_thread)
            
            self.compare_worker.progress.connect(self.update_progress)
            self.compare_worker.results_ready.connect(self.show_compare_results)
            self.compare_worker.finished.connect(self.compare_thread.quit)
            self.compare_worker.finished.connect(self.compare_worker.deleteLater)
            self.compare_thread.finished.connect(self.compare_thread.deleteLater)
            
            self.compare_thread.started.connect(self.compare_worker.process)
            self.compare_thread.start()

        except Exception as e:
            self.update_status(f"Ошибка: {str(e)}")
            self.compare_progress.setVisible(False)
            self.end_operation()

    def show_compare_results(self, results):
        self.compare_progress.setVisible(False)
        self.end_operation()
        
        self.current_results = results
        self.results_output.clear()
        for res in results:
            self.results_output.append(res)
            self.results_output.append("")
            
        self.save_btn.setEnabled(True)
        self.update_status("Сравнение завершено")
        QMessageBox.information(self, "Успех", "Сравнение выполнено успешно!")

    def show_results(self, results):
        self.analysis_progress.setVisible(False)
        self.end_operation()
        
        self.current_results = results
        self.results_output.clear()
        for res in results:
            self.results_output.append(res)
            self.results_output.append("")
            
        self.save_btn.setEnabled(True)
        self.update_status("Результаты анализа получены")
        QMessageBox.information(self, "Успех", "Анализ завершен успешно!")

    def handle_data_loaded(self, success):
        self.data_progress.setVisible(False)
        self.end_operation()
        
        if success:
            self.file_combo.clear()
            self.threat_combo.clear()
            self.vuln_combo.clear()
            
            for file in self.worker.loaded_files:
                filename = os.path.basename(file)
                self.file_combo.addItem(filename)
                self.threat_combo.addItem(filename)
                self.vuln_combo.addItem(filename)
                
            self.update_status(f"Загружено {len(self.worker.all_descriptions)} описаний из {len(self.worker.loaded_files)} файлов")
            QMessageBox.information(self, "Успех", "Данные успешно загружены!")
        else:
            self.update_status("Ошибка при загрузке данных")
            QMessageBox.critical(self, "Ошибка", "Не удалось загрузить данные")

    def handle_stopwords_loaded(self, success):
        self.stopwords_progress.setVisible(False)
        self.end_operation()
        
        if success:
            self.update_status(f"Загружено {len(self.worker.stop_words)} стоп-слов")
            QMessageBox.information(self, "Успех", "Стоп-слова успешно загружены!")
        else:
            self.update_status("Ошибка при загрузке стоп-слов")
            QMessageBox.critical(self, "Ошибка", "Не удалось загрузить стоп-слова")

    def handle_model_loaded(self, success):
        self.model_progress.setVisible(False)
        self.end_operation()
        
        if success:
            self.save_model_btn.setEnabled(True)
            self.update_status("Модель успешно загружена")
            QMessageBox.information(self, "Успех", "Модель успешно загружена!")
        else:
            self.update_status("Ошибка при загрузке модели")
            QMessageBox.critical(self, "Ошибка", "Не удалось загрузить модель")

    def handle_model_trained(self, success):
        self.train_progress.setVisible(False)
        self.end_operation()
        
        if success:
            self.save_model_btn.setEnabled(True)
            if hasattr(self.worker, 'model') and self.worker.model is not None:
                self.update_status("Модель успешно дообучена!")
                QMessageBox.information(self, "Успех", "Модель успешно дообучена!")
            else:
                self.update_status("Модель успешно обучена!")
                QMessageBox.information(self, "Успех", "Модель успешно обучена!")
        else:
            self.update_status("Ошибка при обучении модели")
            QMessageBox.critical(self, "Ошибка", "Не удалось обучить модель")

    def update_status(self, message):
        self.status_bar.setText(message)

    def update_progress(self, value):
        if self.data_progress.isVisible():
            self.data_progress.setValue(value)
        elif self.stopwords_progress.isVisible():
            self.stopwords_progress.setValue(value)
        elif self.model_progress.isVisible():
            self.model_progress.setValue(value)
        elif self.train_progress.isVisible():
            self.train_progress.setValue(value)
        elif self.analysis_progress.isVisible():
            self.analysis_progress.setValue(value)
        elif self.compare_progress.isVisible():
            self.compare_progress.setValue(value)

    def save_results(self):
        if not self.current_results:
            QMessageBox.warning(self, "Предупреждение", "Нет результатов для сохранения")
            return
            
        selected_format = self.format_combo.currentText()
        if selected_format == "Текстовый файл":
            filepath, _ = QFileDialog.getSaveFileName(
                self, "Сохранить результаты", "", "Text Files (*.txt)"
            )
            if filepath:
                if not filepath.endswith('.txt'):
                    filepath += '.txt'
                try:
                    with open(filepath, "w", encoding="utf-8") as f:
                        for line in self.current_results:
                            f.write(line + "\n\n")
                    self.update_status(f"Результаты сохранены в {filepath}")
                except Exception as e:
                    QMessageBox.critical(self, "Ошибка", f"Не удалось сохранить результаты: {str(e)}")
        elif selected_format == "Документ Word" and Document:
            filepath, _ = QFileDialog.getSaveFileName(
                self, "Сохранить результаты", "", "Word Documents (*.docx)"
            )
            if filepath:
                if not filepath.endswith('.docx'):
                    filepath += '.docx'
                try:
                    document = Document()
                    for line in self.current_results:
                        document.add_paragraph(line)
                        document.add_paragraph("")
                    document.save(filepath)
                    self.update_status(f"Результаты сохранены в {filepath}")
                except Exception as e:
                    QMessageBox.critical(self, "Ошибка", f"Не удалось сохранить результаты: {str(e)}")
        else:
            QMessageBox.warning(self, "Ошибка", "Формат Word недоступен. Установите python-docx")

    def closeEvent(self, event):
        self.worker.should_stop = True
        if hasattr(self, 'compare_worker'):
            self.compare_worker.should_stop = True
        self.responsiveness_timer.stop()
        
        if self.worker_thread.isRunning():
            self.worker_thread.quit()
            if not self.worker_thread.wait(2000):
                self.worker_thread.terminate()
                
        if hasattr(self, 'compare_thread') and self.compare_thread.isRunning():
            self.compare_thread.quit()
            if not self.compare_thread.wait(2000):
                self.compare_thread.terminate()
                
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    app.setStyle('Fusion')
    
    font = QFont()
    font.setFamily("Segoe UI")
    font.setPointSize(10)
    app.setFont(font)
    
    window = MainWindow()
    
    if Document is None:
        window.format_combo.setItemText(1, "Документ Word (недоступен)")
        window.format_combo.model().item(1).setEnabled(False)
    
    window.show()
    sys.exit(app.exec())
